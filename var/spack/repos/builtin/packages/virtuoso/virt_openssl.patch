diff -u -r -N virtuoso-opensource-o/configure.ac virtuoso-opensource-7.2.5.1/configure.ac
--- virtuoso-opensource-o/configure.ac	2021-01-08 13:27:46.000000000 +0900
+++ virtuoso-opensource-7.2.5.1/configure.ac	2021-01-08 13:35:30.000000000 +0900
@@ -865,6 +865,10 @@
 *-sunos*)
 	LIBS="$LIBS -lsocket"
 	;;
+
+*-linux*)
+	LIBS="$LIBS -ldl -lpthread"
+	;;
 esac
 
 AC_MSG_CHECKING([OpenSSL version])
@@ -884,13 +888,13 @@
 AC_TRY_COMPILE([
 #include <openssl/opensslv.h>
 ],[
-#if OPENSSL_VERSION_NUMBER >= 0x1010000fL
+#if OPENSSL_VERSION_NUMBER >= 0x1020000fL
 #error OpenSSL version too new
 #endif
     ],[
-      AC_MSG_RESULT([< 1.1.0])
+      AC_MSG_RESULT([< 1.2.0])
     ],[
-      AC_MSG_ERROR([OpenSSL version 1.1.0 or greater is currently not supported.])
+      AC_MSG_ERROR([OpenSSL version 1.2.0 or greater is currently not supported.])
     ])
 
 AC_MSG_CHECKING([usability of the OpenSSL header files and library in ${openssl_dir}])
diff -u -r -N virtuoso-opensource-o/libsrc/Dk/Dkernel.c virtuoso-opensource-7.2.5.1/libsrc/Dk/Dkernel.c
--- virtuoso-opensource-o/libsrc/Dk/Dkernel.c	2021-01-08 13:27:51.000000000 +0900
+++ virtuoso-opensource-7.2.5.1/libsrc/Dk/Dkernel.c	2021-01-08 13:37:01.000000000 +0900
@@ -71,6 +71,9 @@
 #include <openssl/asn1.h>
 #include <openssl/pkcs12.h>
 #include <openssl/rand.h>
+#include <openssl/ec.h>
+
+#include "util/ssl_compat.h"
 
 static void ssl_server_init ();
 
@@ -4900,9 +4903,7 @@
   if (( errnum == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
 	|| errnum == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN
 	|| errnum == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY
-#if OPENSSL_VERSION_NUMBER >= 0x00905000
 	|| errnum == X509_V_ERR_CERT_UNTRUSTED
-#endif
 	|| errnum == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE)
       && ssl_server_verify == 3)
     {
@@ -5087,11 +5088,12 @@
 #define SSL_PROTOCOL_TLSV1 (1<<2)
 #define SSL_PROTOCOL_TLSV1_1 (1<<3)
 #define SSL_PROTOCOL_TLSV1_2 (1<<4)
+#define SSL_PROTOCOL_TLSV1_3 (1<<5)
 
 #if OPENSSL_VERSION_NUMBER >= 0x1000100FL
-#define SSL_PROTOCOL_ALL   (SSL_PROTOCOL_TLSV1_1|SSL_PROTOCOL_TLSV1_2)
+#define SSL_PROTOCOL_ALL   (SSL_PROTOCOL_TLSV1_2|SSL_PROTOCOL_TLSV1_3)
 #else
-#define SSL_PROTOCOL_ALL   (SSL_PROTOCOL_TLSV1)
+#define SSL_PROTOCOL_ALL   (SSL_PROTOCOL_TLSV1|SSL_PROTOCOL_TLSV1_1|SSL_PROTOCOL_TLSV1_2)
 #endif
 
 #define	VIRTUOSO_DEFAULT_CIPHER_LIST "HIGH:!aNULL:!eNULL:!RC4:!DES:!MD5:!PSK:!SRP:!KRB5:!SSLv2:!EXP:!MEDIUM:!LOW:!DES-CBC-SHA:@STRENGTH"
@@ -5219,6 +5221,20 @@
     ctx_options |= SSL_OP_NO_TLSv1_2;
 #endif
 
+
+/*
+ *  On OpenSSL 1.1.0 and above set min/max proto
+ */
+#ifdef SSL_CTX_set_min_proto_version
+    SSL_CTX_set_min_proto_version(ctx, 0);
+    SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION);
+#endif
+
+#ifdef TLS1_3_VERSION
+    SSL_CTX_set_min_proto_version(ctx, 0);
+    SSL_CTX_set_max_proto_version(ctx, TLS1_3_VERSION);
+#endif
+
   /*
    *  Disable compression on OpenSSL >= 1.0 to fix "CRIME" attack
    */
@@ -5265,9 +5281,7 @@
   CRYPTO_set_locked_mem_functions (dk_ssl_alloc, dk_ssl_free);
 #endif
 
-#if (OPENSSL_VERSION_NUMBER >= 0x00908000L)
   SSL_library_init ();
-#endif
 
   SSL_load_error_strings ();
   ERR_load_crypto_strings ();
@@ -5280,7 +5294,6 @@
   }
 #endif
 
-  SSLeay_add_all_algorithms ();
   PKCS12_PBE_add ();		/* stub */
 
 #ifdef NO_THREAD
diff -u -r -N virtuoso-opensource-o/libsrc/util/ssl_compat.h virtuoso-opensource-7.2.5.1/libsrc/util/ssl_compat.h
--- virtuoso-opensource-o/libsrc/util/ssl_compat.h	1970-01-01 09:00:00.000000000 +0900
+++ virtuoso-opensource-7.2.5.1/libsrc/util/ssl_compat.h	2021-01-08 13:35:30.000000000 +0900
@@ -0,0 +1,669 @@
+/*
+ *  ssl_compat.h
+ *
+ *  This file is part of the OpenLink Software Virtuoso Open-Source (VOS)
+ *  project.
+ *
+ *  Copyright (C) 1998-2020 OpenLink Software
+ *
+ *  This project is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; only version 2 of the License, dated June 1991.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ *  This file contains OpenSSL 1.1.x compatible API functions for
+ *  compiling Virtuoso against the following versions of OpenSSL and LibreSSL:
+ *
+ *    OpenSSL 0.9.8
+ *    OpenSSL 1.0.0
+ *    OpenSSL 1.0.1
+ *    OpenSSL 1.0.2
+ *    OpenSSL 1.1.0
+ *    OpenSSL 1.1.1
+ *
+ *    LibreSSL 2.x
+ *    LibreSSL 3.x
+ *
+ *  Based on information from:
+ *      https://wiki.openssl.org/index.php/OpenSSL_1.1.0_Changes
+ *
+ *  and various source archives.
+ *
+ */
+
+#if defined (_SSL) && !defined (_SSL_COMPAT_H)
+#define _SSL_COMPAT_H
+
+
+#include <openssl/opensslv.h>
+
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+
+#include <string.h>
+#include <openssl/engine.h>
+#include <openssl/bn.h>
+#include <openssl/rand.h>
+#include <openssl/evp.h>
+#include <openssl/dh.h>
+#include <openssl/ecdh.h>
+#include <openssl/md5.h>
+#include <openssl/sha.h>
+#include <openssl/lhash.h>
+#include <openssl/hmac.h>
+#include <openssl/x509.h>
+
+/*
+ *  Macros for backward compatible LHASH
+ */
+#if (OPENSSL_VERSION_NUMBER < 0x10000000L)
+#define _LHASH LHASH
+#endif
+
+#define OPENSSL_LH_DOALL_FUNC	LHASH_DOALL_FN_TYPE
+
+#define OPENSSL_LH_delete	lh_delete
+#define OPENSSL_LH_free		lh_free
+#define OPENSSL_LH_insert	lh_insert
+#define OPENSSL_LH_new		lh_new
+#define OPENSSL_LH_retrieve	lh_retrieve
+#define OPENSSL_LH_strhash	lh_strhash
+#define OPENSSL_LH_doall	lh_doall
+
+
+/*
+ *  OpenSSL 1.1 simple function name remap
+ */
+#define OPENSSL_malloc_init	CRYPTO_malloc_init
+
+
+/*
+ *  Check INLINE situation
+ */
+#ifndef NDEBUG
+#define NO_SSL_COMPAT_INLINE
+#endif
+
+#ifndef NO_SSL_COMPAT_INLINE
+#  define SSL_COMPAT_INLINE static inline
+#else
+#  define SSL_COMPAT_INLINE static
+#endif
+
+
+/*
+ * ----------------------------------------------------------------------
+ *  DH
+ * ----------------------------------------------------------------------
+ */
+
+SSL_COMPAT_INLINE void
+DH_get0_pqg (const DH * dh, const BIGNUM ** p, const BIGNUM ** q, const BIGNUM ** g)
+{
+  if (p != NULL)
+    *p = dh->p;
+  if (q != NULL)
+    *q = dh->q;
+  if (g != NULL)
+    *g = dh->g;
+}
+
+
+SSL_COMPAT_INLINE int
+DH_set0_pqg (DH * dh, BIGNUM * p, BIGNUM * q, BIGNUM * g)
+{
+  if ((dh->p == NULL && p == NULL) || (dh->g == NULL && g == NULL))
+    return 0;
+
+  if (p != NULL)
+    {
+      BN_free (dh->p);
+      dh->p = p;
+    }
+  if (q != NULL)
+    {
+      BN_free (dh->q);
+      dh->q = q;
+    }
+  if (g != NULL)
+    {
+      BN_free (dh->g);
+      dh->g = g;
+    }
+  if (q != NULL)
+    {
+      dh->length = BN_num_bits (q);
+    }
+
+  return 1;
+}
+
+
+SSL_COMPAT_INLINE void
+DH_get0_key (const DH * dh, const BIGNUM ** pub_key, const BIGNUM ** priv_key)
+{
+  if (pub_key != NULL)
+    *pub_key = dh->pub_key;
+  if (priv_key != NULL)
+    *priv_key = dh->priv_key;
+}
+
+
+SSL_COMPAT_INLINE int
+DH_set0_key (DH * dh, BIGNUM * pub_key, BIGNUM * priv_key)
+{
+  if (dh->pub_key == NULL && pub_key == NULL)
+    return 0;
+
+  if (pub_key != NULL)
+    {
+      BN_free (dh->pub_key);
+      dh->pub_key = pub_key;
+    }
+  if (priv_key != NULL)
+    {
+      BN_free (dh->priv_key);
+      dh->priv_key = priv_key;
+    }
+  return 1;
+}
+
+
+SSL_COMPAT_INLINE int
+DH_set_length (DH * dh, long length)
+{
+  dh->length = length;
+  return 1;
+}
+
+
+/*
+ * ----------------------------------------------------------------------
+ *  DSA
+ * ----------------------------------------------------------------------
+ */
+
+SSL_COMPAT_INLINE int
+DSA_set0_pqg (DSA * d, BIGNUM * p, BIGNUM * q, BIGNUM * g)
+{
+  if ((d->p == NULL && p == NULL) || (d->q == NULL && q == NULL) || (d->g == NULL && g == NULL))
+    return 0;
+
+  if (p != NULL)
+    {
+      BN_free (d->p);
+      d->p = p;
+    }
+  if (q != NULL)
+    {
+      BN_free (d->q);
+      d->q = q;
+    }
+  if (g != NULL)
+    {
+      BN_free (d->g);
+      d->g = g;
+    }
+  return 1;
+}
+
+
+SSL_COMPAT_INLINE void
+DSA_get0_key (const DSA * d, const BIGNUM ** pub_key, const BIGNUM ** priv_key)
+{
+  if (pub_key != NULL)
+    *pub_key = d->pub_key;
+  if (priv_key != NULL)
+    *priv_key = d->priv_key;
+}
+
+
+SSL_COMPAT_INLINE int
+DSA_set0_key (DSA * d, BIGNUM * pub_key, BIGNUM * priv_key)
+{
+  if (d->pub_key == NULL && pub_key == NULL)
+    return 0;
+
+  if (pub_key != NULL)
+    {
+      BN_free (d->pub_key);
+      d->pub_key = pub_key;
+    }
+  if (priv_key != NULL)
+    {
+      BN_free (d->priv_key);
+      d->priv_key = priv_key;
+    }
+  return 1;
+}
+
+
+SSL_COMPAT_INLINE void
+DSA_SIG_get0 (const DSA_SIG * sig, const BIGNUM ** pr, const BIGNUM ** ps)
+{
+  if (pr != NULL)
+    *pr = sig->r;
+  if (ps != NULL)
+    *ps = sig->s;
+}
+
+
+SSL_COMPAT_INLINE int
+DSA_SIG_set0 (DSA_SIG * sig, BIGNUM * r, BIGNUM * s)
+{
+  if (r == NULL || s == NULL)
+    return 0;
+  BN_clear_free (sig->r);
+  BN_clear_free (sig->s);
+  sig->r = r;
+  sig->s = s;
+  return 1;
+}
+
+
+/*
+ * ----------------------------------------------------------------------
+ * EVP
+ * ----------------------------------------------------------------------
+ */
+
+SSL_COMPAT_INLINE int
+EVP_PKEY_up_ref (EVP_PKEY * pkey)
+{
+  return CRYPTO_add (&(pkey)->references, 0, CRYPTO_LOCK_EVP_PKEY);
+}
+
+
+#if OPENSSL_VERSION_NUMBER < 0x10000000L
+SSL_COMPAT_INLINE int
+EVP_PKEY_id (const EVP_PKEY * pkey)
+{
+  return pkey->type;
+}
+#endif
+
+
+SSL_COMPAT_INLINE DSA *
+EVP_PKEY_get0_DSA (EVP_PKEY * pkey)
+{
+  if (pkey->type != EVP_PKEY_DSA)
+    return NULL;
+  return pkey->pkey.dsa;
+}
+
+
+SSL_COMPAT_INLINE RSA *
+EVP_PKEY_get0_RSA (EVP_PKEY * pkey)
+{
+  if (pkey->type != EVP_PKEY_RSA)
+    return NULL;
+  return pkey->pkey.rsa;
+}
+
+
+SSL_COMPAT_INLINE DH *
+EVP_PKEY_get0_DH (EVP_PKEY * pkey)
+{
+  if (pkey->type != EVP_PKEY_DH)
+    return NULL;
+  return pkey->pkey.dh;
+}
+
+
+SSL_COMPAT_INLINE const unsigned char *
+EVP_CIPHER_CTX_iv (const EVP_CIPHER_CTX * ctx)
+{
+  return ctx->iv;
+}
+
+
+SSL_COMPAT_INLINE unsigned char *
+EVP_CIPHER_CTX_iv_noconst (EVP_CIPHER_CTX * ctx)
+{
+  return ctx->iv;
+}
+
+
+SSL_COMPAT_INLINE EVP_MD_CTX *
+EVP_MD_CTX_new (void)
+{
+  EVP_MD_CTX *ctx = (EVP_MD_CTX *) OPENSSL_malloc (sizeof (EVP_MD_CTX));
+  if (ctx)
+    memset (ctx, '\0', sizeof (EVP_MD_CTX));
+  return ctx;
+}
+
+
+SSL_COMPAT_INLINE void
+EVP_MD_CTX_free (EVP_MD_CTX * ctx)
+{
+  EVP_MD_CTX_cleanup (ctx);
+  OPENSSL_free (ctx);
+}
+
+
+/*
+ * ----------------------------------------------------------------------
+ * HMAC
+ * ----------------------------------------------------------------------
+ */
+
+SSL_COMPAT_INLINE HMAC_CTX *
+HMAC_CTX_new (void)
+{
+  HMAC_CTX *ctx = OPENSSL_malloc (sizeof (HMAC_CTX));
+  if (ctx != NULL)
+    HMAC_CTX_init (ctx);
+  return ctx;
+}
+
+
+SSL_COMPAT_INLINE void
+HMAC_CTX_free (HMAC_CTX * ctx)
+{
+  if (ctx != NULL)
+    {
+      HMAC_CTX_cleanup (ctx);
+      OPENSSL_free (ctx);
+    }
+}
+
+
+/*
+ * ----------------------------------------------------------------------
+ * RSA
+ * ----------------------------------------------------------------------
+ */
+
+SSL_COMPAT_INLINE int
+RSA_set0_key (RSA * r, BIGNUM * n, BIGNUM * e, BIGNUM * d)
+{
+  /* If the fields n and e in r are NULL, the corresponding input
+   * parameters MUST be non-NULL for n and e.  d may be
+   * left NULL (in case only the public key is used).
+   */
+  if ((r->n == NULL && n == NULL) || (r->e == NULL && e == NULL))
+    return 0;
+
+  if (n != NULL)
+    {
+      BN_free (r->n);
+      r->n = n;
+    }
+  if (e != NULL)
+    {
+      BN_free (r->e);
+      r->e = e;
+    }
+  if (d != NULL)
+    {
+      BN_free (r->d);
+      r->d = d;
+    }
+
+  return 1;
+}
+
+
+SSL_COMPAT_INLINE int
+RSA_set0_factors (RSA * r, BIGNUM * p, BIGNUM * q)
+{
+  /* If the fields p and q in r are NULL, the corresponding input
+   * parameters MUST be non-NULL.
+   */
+  if ((r->p == NULL && p == NULL) || (r->q == NULL && q == NULL))
+    return 0;
+
+  if (p != NULL)
+    {
+      BN_free (r->p);
+      r->p = p;
+    }
+  if (q != NULL)
+    {
+      BN_free (r->q);
+      r->q = q;
+    }
+  return 1;
+}
+
+
+SSL_COMPAT_INLINE int
+RSA_set0_crt_params (RSA * r, BIGNUM * dmp1, BIGNUM * dmq1, BIGNUM * iqmp)
+{
+  /* If the fields dmp1, dmq1 and iqmp in r are NULL, the corresponding input
+   * parameters MUST be non-NULL.
+   */
+  if ((r->dmp1 == NULL && dmp1 == NULL) || (r->dmq1 == NULL && dmq1 == NULL) || (r->iqmp == NULL && iqmp == NULL))
+    return 0;
+
+  if (dmp1 != NULL)
+    {
+      BN_free (r->dmp1);
+      r->dmp1 = dmp1;
+    }
+  if (dmq1 != NULL)
+    {
+      BN_free (r->dmq1);
+      r->dmq1 = dmq1;
+    }
+  if (iqmp != NULL)
+    {
+      BN_free (r->iqmp);
+      r->iqmp = iqmp;
+    }
+  return 1;
+}
+
+
+SSL_COMPAT_INLINE void
+RSA_get0_key (const RSA * r, const BIGNUM ** n, const BIGNUM ** e, const BIGNUM ** d)
+{
+  if (n != NULL)
+    *n = r->n;
+  if (e != NULL)
+    *e = r->e;
+  if (d != NULL)
+    *d = r->d;
+}
+
+
+SSL_COMPAT_INLINE void
+RSA_get0_factors (const RSA * r, const BIGNUM ** p, const BIGNUM ** q)
+{
+  if (p != NULL)
+    *p = r->p;
+  if (q != NULL)
+    *q = r->q;
+}
+
+
+SSL_COMPAT_INLINE void
+RSA_get0_crt_params (const RSA * r, const BIGNUM ** dmp1, const BIGNUM ** dmq1, const BIGNUM ** iqmp)
+{
+  if (dmp1 != NULL)
+    *dmp1 = r->dmp1;
+  if (dmq1 != NULL)
+    *dmq1 = r->dmq1;
+  if (iqmp != NULL)
+    *iqmp = r->iqmp;
+}
+
+
+SSL_COMPAT_INLINE void
+DSA_get0_pqg (const DSA * d, const BIGNUM ** p, const BIGNUM ** q, const BIGNUM ** g)
+{
+  if (p != NULL)
+    *p = d->p;
+  if (q != NULL)
+    *q = d->q;
+  if (g != NULL)
+    *g = d->g;
+}
+
+
+SSL_COMPAT_INLINE RSA_METHOD *
+RSA_meth_dup (const RSA_METHOD * meth)
+{
+  RSA_METHOD *ret;
+
+  ret = OPENSSL_malloc (sizeof (RSA_METHOD));
+
+  if (ret != NULL)
+    {
+      memcpy (ret, meth, sizeof (RSA_METHOD));
+      ret->name = OPENSSL_malloc (strlen(meth->name) + 1);
+      if (ret->name == NULL)
+	{
+	  OPENSSL_free (ret);
+	  return NULL;
+	}
+      strcpy (ret->name, meth->name);
+    }
+  return ret;
+}
+
+
+SSL_COMPAT_INLINE int
+RSA_meth_set1_name (RSA_METHOD * meth, const char *name)
+{
+  char *tmpname;
+
+  tmpname = OPENSSL_malloc (strlen(name) + 1);
+  if (tmpname == NULL)
+    {
+      return 0;
+    }
+  strcpy (tmpname, meth->name);
+  OPENSSL_free ((char *) meth->name);
+  meth->name = tmpname;
+
+  return 1;
+}
+
+
+SSL_COMPAT_INLINE int
+RSA_meth_set_priv_enc (RSA_METHOD * meth,
+    int (*priv_enc) (int flen, const unsigned char *from, unsigned char *to, RSA * rsa, int padding))
+{
+  meth->rsa_priv_enc = priv_enc;
+  return 1;
+}
+
+
+SSL_COMPAT_INLINE int
+RSA_meth_set_priv_dec (RSA_METHOD * meth,
+    int (*priv_dec) (int flen, const unsigned char *from, unsigned char *to, RSA * rsa, int padding))
+{
+  meth->rsa_priv_dec = priv_dec;
+  return 1;
+}
+
+
+SSL_COMPAT_INLINE int
+RSA_meth_set_finish (RSA_METHOD * meth, int (*finish) (RSA * rsa))
+{
+  meth->finish = finish;
+  return 1;
+}
+
+
+SSL_COMPAT_INLINE void
+RSA_meth_free (RSA_METHOD * meth)
+{
+  if (meth != NULL)
+    {
+      OPENSSL_free ((char *) meth->name);
+      OPENSSL_free (meth);
+    }
+}
+
+
+SSL_COMPAT_INLINE int
+RSA_bits (const RSA * r)
+{
+  return (BN_num_bits (r->n));
+}
+
+
+/*
+ * ----------------------------------------------------------------------
+ * X509
+ * ----------------------------------------------------------------------
+ */
+
+SSL_COMPAT_INLINE int
+X509_up_ref (X509 * x)
+{
+  return CRYPTO_add (&x->references, 1, CRYPTO_LOCK_X509);
+}
+
+
+SSL_COMPAT_INLINE
+STACK_OF (X509_OBJECT) *
+X509_STORE_get0_objects (X509_STORE * v)
+{
+  return v->objs;
+}
+
+
+SSL_COMPAT_INLINE int
+X509_OBJECT_get_type (const X509_OBJECT * a)
+{
+  return a->type;
+}
+
+
+SSL_COMPAT_INLINE X509 *
+X509_OBJECT_get0_X509 (const X509_OBJECT * a)
+{
+  if (a == NULL || a->type != X509_LU_X509)
+    return NULL;
+  return a->data.x509;
+}
+
+
+SSL_COMPAT_INLINE const
+STACK_OF (X509_EXTENSION) *
+X509_get0_extensions (const X509 * x)
+{
+  return x->cert_info->extensions;
+}
+
+
+SSL_COMPAT_INLINE int X509_CRL_up_ref(X509_CRL *crl)
+{
+  return CRYPTO_add (&crl->references, 1, CRYPTO_LOCK_X509_CRL);
+}
+
+
+#if OPENSSL_VERSION_NUMBER < 0x1000100FL
+SSL_COMPAT_INLINE
+void SSL_set_state(SSL *ssl, int state)
+{
+	ssl->state = state;
+}
+#endif
+
+
+#if OPENSSL_VERSION_NUMBER < 0x10002000L
+SSL_COMPAT_INLINE
+void X509_get0_signature(ASN1_BIT_STRING **psig, X509_ALGOR **palg, const X509 *x)
+{
+    if (psig)
+        *psig = x->signature;
+    if (palg)
+        *palg = x->sig_alg;
+}
+#endif
+
+#endif /* OPENSSL_VERSION_NUMBER */
+#endif /* _SSL */
diff -u -r -N virtuoso-opensource-o/libsrc/util/sslengine.c virtuoso-opensource-7.2.5.1/libsrc/util/sslengine.c
--- virtuoso-opensource-o/libsrc/util/sslengine.c	2021-01-08 13:27:53.000000000 +0900
+++ virtuoso-opensource-7.2.5.1/libsrc/util/sslengine.c	2021-01-08 13:35:30.000000000 +0900
@@ -26,10 +26,18 @@
 #include "util/sslengine.h"
 #include <openssl/err.h>
 
+
+/*
+ *  Backward compatibility
+ */
+#ifndef OPENSSL_malloc_init
+#define OPENSSL_malloc_init    CRYPTO_malloc_init
+#endif
+
 int
 ssl_engine_startup (void)
 {
-  CRYPTO_malloc_init ();
+  OPENSSL_malloc_init ();
   ERR_load_crypto_strings();
   OpenSSL_add_all_algorithms();
 
diff -u -r -N virtuoso-opensource-o/libsrc/Wi/bif_crypto.c virtuoso-opensource-7.2.5.1/libsrc/Wi/bif_crypto.c
--- virtuoso-opensource-o/libsrc/Wi/bif_crypto.c	2021-01-08 13:27:52.000000000 +0900
+++ virtuoso-opensource-7.2.5.1/libsrc/Wi/bif_crypto.c	2021-01-08 13:37:01.000000000 +0900
@@ -49,6 +49,8 @@
 #include <openssl/err.h>
 #include <openssl/ssl.h>
 
+#include "util/ssl_compat.h"
+
 #define DO_BOX_ALG_1(A_TYPE,A_NAME,A_PREFIX) \
 void \
 box_##A_NAME##_1 (caddr_t box, A_TYPE##_CTX * ctx) \
@@ -181,21 +183,25 @@
   unsigned char temp[EVP_MAX_MD_SIZE];
   unsigned int size = 0;
   caddr_t res = NULL;
-  HMAC_CTX ctx;
+  HMAC_CTX *ctx;
   const EVP_MD *md = EVP_sha1 ();
 
   if (alg == 1)
     md = EVP_ripemd160 ();
 
-  HMAC_Init (&ctx, key, box_length (key) - DV_STRINGP (key) ? 1 : 0, md);
-  box_hmac_1 (box, &ctx);
-  HMAC_Final (&ctx, temp, &size);
+  if ((ctx = HMAC_CTX_new()) == NULL)
+    return NULL;
+
+  HMAC_Init_ex (ctx, key, box_length (key) - DV_STRINGP (key) ? 1 : 0, md, NULL);
+  box_hmac_1 (box, ctx);
+  HMAC_Final (ctx, temp, &size);
   if (size)
     {
       res = dk_alloc_box (size + 1, DV_SHORT_STRING);
       memcpy (res, temp, size);
       res[size] = 0;
     }
+  HMAC_CTX_free (ctx);
   return res;
 }
 
@@ -345,16 +351,14 @@
 	    }
 	  else if (tag == V_ASN1_BOOLEAN)
 	    {
-	      int ii;
-
 	      opp = op;
-	      ii = d2i_ASN1_BOOLEAN (NULL, (const unsigned char **)&opp, len + hl);
-	      if (ii < 0)
+	      if (len != 1)
 		{
 		  if (BIO_write (bp, "Bad boolean\n", 12))
 		    goto end;
 		}
-	      BIO_printf (bp, "%d", ii);
+	      if (len > 0)
+	        BIO_printf (bp, "%u", p[0]);
 	    }
 	  else if (tag == V_ASN1_BMPSTRING)
 	    {
@@ -415,7 +419,7 @@
 		}
 	      if (os != NULL)
 		{
-		  M_ASN1_OCTET_STRING_free (os);
+		  ASN1_STRING_free (os);
 		  os = NULL;
 		}
 	    }
@@ -448,7 +452,7 @@
 		  if (BIO_write (bp, "BAD INTEGER", 11) <= 0)
 		    goto end;
 		}
-	      M_ASN1_INTEGER_free (bs);
+	      ASN1_INTEGER_free (bs);
 	    }
 	  else if (tag == V_ASN1_ENUMERATED)
 	    {
@@ -479,7 +483,7 @@
 		  if (BIO_write (bp, "BAD ENUMERATED", 11) <= 0)
 		    goto end;
 		}
-	      M_ASN1_ENUMERATED_free (bs);
+	      ASN1_ENUMERATED_free (bs);
 	    }
 	  else if (len > 0 && dump)
 	    {
@@ -515,7 +519,7 @@
   if (o != NULL)
     ASN1_OBJECT_free (o);
   if (os != NULL)
-    M_ASN1_OCTET_STRING_free (os);
+    ASN1_OCTET_STRING_free (os);
   *pp = p;
   return (ret);
 }
@@ -718,12 +722,11 @@
 bio_to_strses (BIO * out_bio)
 {
   dk_session_t * ses = strses_allocate ();
-  char buf[4096], *to_free;
+  char buf[4096];
   char *ptr = NULL;
   int len = BIO_get_mem_data (out_bio, &ptr);
   int to_read = len, readed = 0;
 
-  to_free = ((BUF_MEM *) out_bio->ptr)->data;
   BIO_set_flags (out_bio, BIO_FLAGS_MEM_RDONLY);
   CATCH_WRITE_FAIL (ses)
     {
@@ -735,7 +738,7 @@
       } while (to_read > 0);
     }
   END_WRITE_FAIL (ses);
-  ((BUF_MEM *) out_bio->ptr)->data = to_free;
+  BIO_reset (out_bio);
   BIO_clear_flags (out_bio, BIO_FLAGS_MEM_RDONLY);
   return ses;
 }
@@ -746,6 +749,7 @@
   caddr_t msg = bif_arg (qst, args, 0, "smime_verify");
   caddr_t certs = bif_array_arg (qst, args, 1, "smime_verify");
   int flags = 0;
+  int bio_readonly = 0;
   caddr_t ret = NULL;
 
   caddr_t err = NULL;
@@ -770,19 +774,19 @@
   if (DV_TYPE_OF (msg) == DV_STRING_SESSION)
     {
       in_bio = strses_to_bio ((dk_session_t *) msg);
-      to_free = ((BUF_MEM *) in_bio->ptr)->data;
       BIO_set_flags (in_bio, BIO_FLAGS_MEM_RDONLY);
+      bio_readonly = 1;
     }
   else
     in_bio = BIO_new_mem_buf (msg, box_length (msg) - 1);
   if (in_bio)
     {
       p7 = SMIME_read_PKCS7 (in_bio, &data_bio);
-      if (to_free)
-	{
-	  ((BUF_MEM *) in_bio->ptr)->data = to_free;
-	  BIO_clear_flags (in_bio, BIO_FLAGS_MEM_RDONLY);
-	}
+      if (bio_readonly)
+        {
+          BIO_reset (in_bio);
+          BIO_clear_flags (in_bio, BIO_FLAGS_MEM_RDONLY);
+        }
       BIO_free (in_bio);
     }
 
@@ -924,13 +928,16 @@
     }
 
   certs = sk_X509_new_null ();
-  if (store && store->objs)
+
+  if (store && X509_STORE_get0_objects(store))
     {
-      for (inx = 0; inx < sk_X509_OBJECT_num (store->objs); inx++)
+      STACK_OF(X509_OBJECT) *store_objs = X509_STORE_get0_objects(store);
+
+      for (inx = 0; inx < sk_X509_OBJECT_num (store_objs); inx++)
 	{
-	  X509_OBJECT *obj = sk_X509_OBJECT_value (store->objs, inx);
-	  if (obj->type == X509_LU_X509)
-	    sk_X509_push (certs, X509_dup (obj->data.x509));
+	  X509_OBJECT *obj = sk_X509_OBJECT_value (store_objs, inx);
+	  if (X509_OBJECT_get_type(obj) == X509_LU_X509)
+	    sk_X509_push (certs, X509_dup (X509_OBJECT_get0_X509(obj)));
 	}
 
     }
@@ -1005,15 +1012,19 @@
     sqlr_new_error ("42000", "CR006", "No recipient certificates");
 
   certs = sk_X509_new_null ();
-  if (store && store->objs)
+
+  if (store && X509_STORE_get0_objects(store))
     {
-      for (inx = 0; inx < sk_X509_OBJECT_num (store->objs); inx++)
+      STACK_OF(X509_OBJECT) *store_objs = X509_STORE_get0_objects(store);
+
+      for (inx = 0; inx < sk_X509_OBJECT_num (store_objs); inx++)
 	{
-	  X509_OBJECT *obj = sk_X509_OBJECT_value (store->objs, inx);
-	  if (obj->type == X509_LU_X509)
-	    sk_X509_push (certs, X509_dup (obj->data.x509));
+	  X509_OBJECT *obj = sk_X509_OBJECT_value (store_objs, inx);
+	  if (X509_OBJECT_get_type(obj) == X509_LU_X509)
+	    sk_X509_push (certs, X509_dup (X509_OBJECT_get0_X509(obj)));
 	}
     }
+
   if (store)
     X509_STORE_free (store);
   in_bio = BIO_new_mem_buf (msg, box_length (msg) - 1);
@@ -1181,7 +1192,7 @@
   char *opts = (char *) X509_STORE_CTX_get_app_data (ctx);
   if (!ok && opts)
     {
-      switch (ctx->error)
+      switch (X509_STORE_CTX_get_error(ctx))
 	{
 	case X509_V_ERR_CERT_HAS_EXPIRED:
 	  if (strstr (opts, "expired"))
@@ -1246,11 +1257,7 @@
     mem_bio = BIO_new_mem_buf (ca, box_length (ca) - 1);
     if (NULL != strstr (ca, PEM_STRING_X509))
       {
-#if OPENSSL_VERSION_NUMBER >= 0x00908000L
 	cacert = (X509 *)PEM_ASN1_read_bio ((d2i_of_void *)d2i_X509, PEM_STRING_X509, mem_bio, NULL, NULL, NULL);
-#else
-	cacert = (X509 *)PEM_ASN1_read_bio ((char *(*)())d2i_X509, PEM_STRING_X509, mem_bio, NULL, NULL, NULL);
-#endif
       }
     else
       cacert = d2i_X509_bio (mem_bio, NULL);
@@ -1270,15 +1277,11 @@
       goto err_ret;
     }
 
-#if (OPENSSL_VERSION_NUMBER < 0x00907000L)
-  X509_STORE_CTX_init (csc, cert_ctx, cert, uchain);
-#else
   if (!X509_STORE_CTX_init (csc, cert_ctx, cert, uchain))
     {
       *err_ret = srv_make_new_error ("22023", "CR018", "Can not initialize X509 verification context");
       goto err_ret;
     }
-#endif
 
   X509_STORE_CTX_set_app_data (csc, (void *) opts);
 
@@ -1287,7 +1290,7 @@
   if (!i)
     {
       const char *err_str;
-      err_str = X509_verify_cert_error_string (csc->error);
+      err_str = X509_verify_cert_error_string (X509_STORE_CTX_get_error(csc));
       *err_ret = srv_make_new_error ("22023", "CR015", "X509 error: %s", err_str);
     }
 
@@ -1308,16 +1311,14 @@
 #define VIRT_CERT_EXT "2.16.840.1.1113.1"
 
 static caddr_t
-BN_box (BIGNUM * x)
+BN_box (const BIGNUM * x)
 {
   size_t buf_len, n;
   caddr_t buf;
   buf_len = (size_t) BN_num_bytes (x);
-  if (buf_len <= BN_BYTES)
-    buf = box_num ((unsigned long) x->d[0]);
-  else
+  buf = dk_alloc_box (buf_len, DV_BIN);
+  if (buf)
     {
-      buf = dk_alloc_box (buf_len, DV_BIN);
       n = BN_bn2bin (x, (unsigned char *) buf);
       if (n != buf_len)
 	GPF_T;
@@ -1498,7 +1499,7 @@
 	int i;
 	char tmp[1024];
 	char *ext_oid = (char *) (BOX_ELEMENTS (args) > 4 ? bif_string_arg (qst, args, 4, "get_certificate_info") : VIRT_CERT_EXT);
-	STACK_OF (X509_EXTENSION) * exts = cert->cert_info->extensions;
+	const STACK_OF (X509_EXTENSION) * exts = X509_get0_extensions(cert);
 	for (i = 0; i < sk_X509_EXTENSION_num (exts); i++)
 	  {
 	    X509_EXTENSION *ex = sk_X509_EXTENSION_value (exts, i);
@@ -1510,7 +1511,7 @@
 		char *data_ptr;
 		BIO *mem = BIO_new (BIO_s_mem ());
 		if (!X509V3_EXT_print (mem, ex, 0, 0))
-		  M_ASN1_OCTET_STRING_print (mem, ex->value);
+		  ASN1_STRING_print (mem, (ASN1_STRING *) X509_EXTENSION_get_data(ex));
 		len = BIO_get_mem_data (mem, &data_ptr);
 		if (len > 0 && data_ptr)
 		  {
@@ -1536,23 +1537,35 @@
 	EVP_PKEY *k = X509_get_pubkey (cert);
 	if (k)
 	  {
+	    switch (EVP_PKEY_id(k))
+	      {
 #ifdef EVP_PKEY_RSA
-	    if (k->type == EVP_PKEY_RSA)
+	      case EVP_PKEY_RSA:
 	      {
-		RSA *x = k->pkey.rsa;
-		ret = list (3, box_dv_short_string ("RSAPublicKey"), BN_box (x->e), BN_box (x->n));
+		  const BIGNUM *n, *e;
+
+		  RSA_get0_key (EVP_PKEY_get0_RSA (k), &n, &e, NULL);
+
+		  ret = list (3, box_dv_short_string ("RSAPublicKey"), BN_box (e), BN_box (n));
+	          break;
 	      }
-	    else
 #endif
+
 #ifdef EVP_PKEY_DSA
-	    if (k->type == EVP_PKEY_DSA)
+	      case EVP_PKEY_DSA:
 	      {
-		DSA *x = k->pkey.dsa;
-		ret = list (2, box_dv_short_string ("DSAPublicKey"), BN_box (x->pub_key));
+		  const BIGNUM *pub_key;
+
+		  DSA_get0_key (EVP_PKEY_get0_DSA (k), &pub_key, NULL);
+
+		  ret = list (2, box_dv_short_string ("DSAPublicKey"), BN_box (pub_key));
+		  break;
 	      }
-	    else
 #endif
+
+	      default:
 	      *err_ret = srv_make_new_error ("42000", "XXXXX", "The certificate's public key not supported");
+	      }
 	    EVP_PKEY_free (k);
 	  }
 	else
@@ -1567,13 +1580,14 @@
 	int n, i, len;
 	char *s, *data_ptr;
 	BIO *mem = BIO_new (BIO_s_mem ());
-	for (i = 0; NULL != subj && i < sk_X509_NAME_ENTRY_num(subj->entries); i++)
+
+	for (i = 0; NULL != subj && i < X509_NAME_entry_count(subj); i++)
 	  {
-	    ne = sk_X509_NAME_ENTRY_value(subj->entries,i);
-	    n = OBJ_obj2nid (ne->object);
+	    ne = X509_NAME_get_entry(subj, i);
+	    n = OBJ_obj2nid (X509_NAME_ENTRY_get_object(ne));
 	    if ((n == NID_undef) || ((s = (char *) OBJ_nid2sn (n)) == NULL))
 	      {
-		i2t_ASN1_OBJECT (buffer, sizeof (buffer), ne->object);
+		i2t_ASN1_OBJECT (buffer, sizeof (buffer), X509_NAME_ENTRY_get_object(ne));
 		s = buffer;
 	      }
 	    if (!strcmp (s, attr))
@@ -1582,9 +1596,10 @@
 		break;
 	      }
 	  }
+
 	if (ne_ret)
 	  {
-	    ASN1_STRING_print (mem, ne_ret->value);
+	    ASN1_STRING_print (mem, X509_NAME_ENTRY_get_data(ne_ret));
 	    len = BIO_get_mem_data (mem, &data_ptr);
 	    if (len > 0 && data_ptr)
 	      {
@@ -1605,17 +1620,18 @@
 	dk_set_t set = NULL;
 	caddr_t val;
 	BIO *mem = BIO_new (BIO_s_mem ());
-	for (i = 0; NULL != subj && i < sk_X509_NAME_ENTRY_num(subj->entries); i++)
+
+	for (i = 0; NULL != subj && i < X509_NAME_entry_count(subj); i++)
 	  {
 	    val = NULL;
-	    ne = sk_X509_NAME_ENTRY_value(subj->entries,i);
-	    n = OBJ_obj2nid (ne->object);
+	    ne = X509_NAME_get_entry(subj, i);
+	    n = OBJ_obj2nid (X509_NAME_ENTRY_get_object(ne));
 	    if ((n == NID_undef) || ((s = (char *) OBJ_nid2sn (n)) == NULL))
 	      {
-		i2t_ASN1_OBJECT (buffer, sizeof (buffer), ne->object);
+		i2t_ASN1_OBJECT (buffer, sizeof (buffer), X509_NAME_ENTRY_get_object(ne));
 		s = buffer;
 	      }
-	    ASN1_STRING_print (mem, ne->value);
+	    ASN1_STRING_print (mem, X509_NAME_ENTRY_get_data(ne));
 	    len = BIO_get_mem_data (mem, &data_ptr);
 	    if (len > 0 && data_ptr)
 	      {
@@ -1635,11 +1651,13 @@
       {
 	const unsigned char *s;
 	int i, n;
-	const ASN1_STRING *sig = cert->signature;
-	X509_ALGOR *sigalg = cert->sig_alg;
+	const ASN1_STRING *sig;
+	const X509_ALGOR *sigalg;
 	char buf[80];
 	caddr_t val;
 
+	X509_get0_signature (&sig, &sigalg, cert);
+
         i2t_ASN1_OBJECT(buf,sizeof (buf), sigalg->algorithm);
 
 	n = sig->length;
@@ -1659,22 +1677,29 @@
 	BIO * b;
 	if (k)
 	  {
+
+	    switch (EVP_PKEY_id (k))
+	      {
 #ifdef EVP_PKEY_RSA
-	    if (k->type == EVP_PKEY_RSA)
+	      case EVP_PKEY_RSA:
 	      {
 		char *data_ptr;
 		int len;
-		RSA *x = k->pkey.rsa;
+		  RSA *x;
+		  x = EVP_PKEY_get0_RSA (k);
 		b = BIO_new (BIO_s_mem());
 		i2d_RSA_PUBKEY_bio (b, x);
 		len = BIO_get_mem_data (b, &data_ptr);
 		ret = dk_alloc_box (len, DV_BIN);
 		memcpy (ret, data_ptr, len);
 		BIO_free (b);
+		  break;
 	      }
-	    else
 #endif
+
+	      default:
 	      *err_ret = srv_make_new_error ("42000", "XXXXX", "The certificate's public key not supported");
+	      }
 	    EVP_PKEY_free (k);
 	  }
 	else
diff -u -r -N virtuoso-opensource-o/libsrc/Wi/http.c virtuoso-opensource-7.2.5.1/libsrc/Wi/http.c
--- virtuoso-opensource-o/libsrc/Wi/http.c	2021-01-08 13:27:52.000000000 +0900
+++ virtuoso-opensource-7.2.5.1/libsrc/Wi/http.c	2021-01-08 13:37:01.000000000 +0900
@@ -72,6 +72,7 @@
 #endif
 #ifdef _SSL
 #include "util/sslengine.h"
+#include "util/ssl_compat.h"
 #endif
 
 #define XML_VERSION		"1.0"
@@ -8721,9 +8722,7 @@
   if ((errnum == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
 	|| errnum == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN
 	|| errnum == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY
-#if OPENSSL_VERSION_NUMBER >= 0x00905000
 	  || errnum == X509_V_ERR_CERT_UNTRUSTED
-#endif
 	|| errnum == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE)
       && verify == HTTPS_VERIFY_OPTIONAL_NO_CA )
     {
@@ -8776,9 +8775,7 @@
   if (( errnum == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
 	|| errnum == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN
 	|| errnum == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY
-#if OPENSSL_VERSION_NUMBER >= 0x00905000
 	|| errnum == X509_V_ERR_CERT_UNTRUSTED
-#endif
 	|| errnum == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE)
       && verify == HTTPS_VERIFY_OPTIONAL_NO_CA )
     {
@@ -8886,7 +8883,7 @@
 		  log_error ("SSL: The stored certificate '%s' can not be used as extra chain certificate", tok);
 		  break;
 		}
-	      CRYPTO_add(&k->xek_x509->references, 1, CRYPTO_LOCK_X509);
+              X509_up_ref (k->xek_x509);
               tok = strtok_r (NULL, ",", &tok_s);
 	    }
 	  dk_free_box (str);
@@ -9949,7 +9946,9 @@
 	  cli_ssl_get_error_string (err_buf, sizeof (err_buf));
 	  sqlr_new_error ("42000", "..002", "SSL_do_handshake failed %s", err_buf);
 	}
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
       ssl->state = SSL_ST_ACCEPT;
+#endif
       while (SSL_renegotiate_pending (ssl) && ctr < 1000)
 	{
 	  timeout_t to = { 0, 1000 };
@@ -11621,8 +11620,6 @@
   /* SSL support */
 #ifdef _SSL
   /*    CRYPTO_malloc_init();*/
-  SSL_load_error_strings();
-  SSLeay_add_ssl_algorithms();
   if (!https_key) /* when key & certificate are in same file */
     https_key = https_cert;
   if (https_port && https_cert && https_key)
diff -u -r -N virtuoso-opensource-o/libsrc/Wi/xmlenc_algos.c virtuoso-opensource-7.2.5.1/libsrc/Wi/xmlenc_algos.c
--- virtuoso-opensource-o/libsrc/Wi/xmlenc_algos.c	2021-01-08 13:27:52.000000000 +0900
+++ virtuoso-opensource-7.2.5.1/libsrc/Wi/xmlenc_algos.c	2021-01-08 13:42:16.000000000 +0900
@@ -48,6 +48,8 @@
 #include <openssl/err.h>
 #include <openssl/hmac.h>
 
+#include "util/ssl_compat.h"
+
 #include "xmlenc_test.h"
 
 #ifdef DEBUG
@@ -1149,7 +1151,7 @@
 dsig_hmac_sha256_digest (dk_session_t * ses_in, long len, xenc_key_t * key, caddr_t * sign_out)
 {
   unsigned char * data;
-  HMAC_CTX ctx;
+  HMAC_CTX *ctx;
   unsigned char key_data[32 * 8];
   unsigned char md [SHA256_DIGEST_LENGTH + 1];
   unsigned char md64 [SHA256_DIGEST_LENGTH * 2 + 1];
@@ -1167,12 +1169,10 @@
 	  memcpy (key_data + 16, key->ki.triple_des.k3, sizeof (DES_cblock));
 	  key_len = 3 * sizeof (DES_cblock);
 	  break;
-#ifdef AES_ENC_ENABLE
       case DSIG_KEY_AES:
 	  memcpy (key_data, key->ki.aes.k, key->ki.aes.bits / 8);
           key_len = key->ki.aes.bits / 8;
 	  break;
-#endif
       case DSIG_KEY_RAW:
 	  if ((key->ki.raw.bits / 8) > sizeof (key_data))
 	    return 0;
@@ -1183,6 +1183,8 @@
 	  return 0;
     }
 
+  if ((ctx = HMAC_CTX_new ()) == NULL)
+    return 0;
 
   data = (unsigned char *) dk_alloc_box (len, DV_C_STRING);
   CATCH_READ_FAIL (ses_in)
@@ -1192,14 +1194,16 @@
   FAILED
     {
       dk_free_box ((box_t) data);
+      HMAC_CTX_free (ctx);
       return 0;
     }
   END_READ_FAIL (ses_in);
 
-  HMAC_Init(&ctx, (void*) key_data , key_len, EVP_sha256 ());
-  HMAC_Update(&ctx, data, len);
-  HMAC_Final(&ctx, md, &hmac_len);
-  HMAC_cleanup(&ctx);
+
+  HMAC_Init_ex(ctx, (void*) key_data , key_len, EVP_sha256 (),NULL);
+  HMAC_Update(ctx, data, len);
+  HMAC_Final(ctx, md, &hmac_len);
+  HMAC_CTX_free(ctx);
 
   if (hmac_len != SHA256_DIGEST_LENGTH)
     GPF_T;
@@ -1220,7 +1224,7 @@
 int
 dsig_hmac_sha256_verify (dk_session_t * ses_in, long len, xenc_key_t * key, caddr_t digest)
 {
-  HMAC_CTX ctx;
+  HMAC_CTX *ctx;
   unsigned char * data;
   unsigned char key_data[3 * 8];
   unsigned char md [SHA256_DIGEST_LENGTH + 1];
@@ -1239,16 +1243,16 @@
 	  memcpy (key_data + 16, key->ki.triple_des.k3, sizeof (DES_cblock));
 	  key_len = 3 * sizeof (DES_cblock);
 	  break;
-#ifdef AES_ENC_ENABLE
       case DSIG_KEY_AES:
 	  memcpy (key_data, key->ki.aes.k, key->ki.aes.bits / 8);
           key_len = key->ki.aes.bits / 8;
 	  break;
-#endif
       default:
 	  return 0;
     }
 
+  if ((ctx = HMAC_CTX_new ()) == NULL)
+    return 0;
 
   data = (unsigned char *) dk_alloc_box (len, DV_C_STRING);
   CATCH_READ_FAIL (ses_in)
@@ -1258,14 +1262,16 @@
   FAILED
     {
       dk_free_box ((box_t) data);
+      HMAC_CTX_free (ctx);
       return 0;
     }
   END_READ_FAIL (ses_in);
 
-  HMAC_Init(&ctx, (void*) key_data , key_len, EVP_sha256 ());
-  HMAC_Update(&ctx, data, len);
-  HMAC_Final(&ctx, md, &hmac_len);
-  HMAC_cleanup(&ctx);
+  HMAC_Init_ex(ctx, (void*) key_data , key_len, EVP_sha256 (), NULL);
+  HMAC_Update(ctx, data, len);
+  HMAC_Final(ctx, md, &hmac_len);
+  HMAC_CTX_free (ctx);
+
   dk_free_box ((box_t) data);
 
   len1 = xenc_encode_base64 ((char *)md, md64, hmac_len);
@@ -1586,7 +1592,7 @@
 dsig_hmac_sha1_digest (dk_session_t * ses_in, long len, xenc_key_t * key, caddr_t * sign_out)
 {
   unsigned char * data;
-  HMAC_CTX ctx;
+  HMAC_CTX *ctx;
   unsigned char key_data[32 * 8];
   unsigned char md [SHA_DIGEST_LENGTH + 1];
   unsigned char md64 [SHA_DIGEST_LENGTH * 2 + 1];
@@ -1604,12 +1610,10 @@
 	  memcpy (key_data + 16, key->ki.triple_des.k3, sizeof (DES_cblock));
 	  key_len = 3 * sizeof (DES_cblock);
 	  break;
-#ifdef AES_ENC_ENABLE
       case DSIG_KEY_AES:
 	  memcpy (key_data, key->ki.aes.k, key->ki.aes.bits / 8);
           key_len = key->ki.aes.bits / 8;
 	  break;
-#endif
       case DSIG_KEY_RAW:
 	  if ((key->ki.raw.bits / 8) > sizeof (key_data))
 	    return 0;
@@ -1620,6 +1624,8 @@
 	  return 0;
     }
 
+  if ((ctx = HMAC_CTX_new ()) == NULL)
+    return 0;
 
   data = (unsigned char *) dk_alloc_box (len, DV_C_STRING);
   CATCH_READ_FAIL (ses_in)
@@ -1629,14 +1635,15 @@
   FAILED
     {
       dk_free_box ((box_t) data);
+      HMAC_CTX_free (ctx);
       return 0;
     }
   END_READ_FAIL (ses_in);
 
-  HMAC_Init(&ctx, (void*) key_data , key_len, EVP_sha1 ());
-  HMAC_Update(&ctx, data, len);
-  HMAC_Final(&ctx, md, &hmac_len);
-  HMAC_cleanup(&ctx);
+  HMAC_Init_ex(ctx, (void*) key_data , key_len, EVP_sha1 (), NULL);
+  HMAC_Update(ctx, data, len);
+  HMAC_Final(ctx, md, &hmac_len);
+  HMAC_CTX_free(ctx);
 
   if (hmac_len != SHA_DIGEST_LENGTH)
     GPF_T;
@@ -1657,7 +1664,7 @@
 int
 dsig_hmac_sha1_verify (dk_session_t * ses_in, long len, xenc_key_t * key, caddr_t digest)
 {
-  HMAC_CTX ctx;
+  HMAC_CTX *ctx;
   unsigned char * data;
   unsigned char key_data[3 * 8];
   unsigned char md [SHA_DIGEST_LENGTH + 1];
@@ -1676,16 +1683,16 @@
 	  memcpy (key_data + 16, key->ki.triple_des.k3, sizeof (DES_cblock));
 	  key_len = 3 * sizeof (DES_cblock);
 	  break;
-#ifdef AES_ENC_ENABLE
       case DSIG_KEY_AES:
 	  memcpy (key_data, key->ki.aes.k, key->ki.aes.bits / 8);
           key_len = key->ki.aes.bits / 8;
 	  break;
-#endif
       default:
 	  return 0;
     }
 
+  if ((ctx = HMAC_CTX_new ()) == NULL)
+    return 0;
 
   data = (unsigned char *) dk_alloc_box (len, DV_C_STRING);
   CATCH_READ_FAIL (ses_in)
@@ -1695,14 +1702,16 @@
   FAILED
     {
       dk_free_box ((box_t) data);
+      HMAC_CTX_free (ctx);
       return 0;
     }
   END_READ_FAIL (ses_in);
 
-  HMAC_Init(&ctx, (void*) key_data , key_len, EVP_sha1 ());
-  HMAC_Update(&ctx, data, len);
-  HMAC_Final(&ctx, md, &hmac_len);
-  HMAC_cleanup(&ctx);
+  HMAC_Init_ex(ctx, (void*) key_data , key_len, EVP_sha1 (), NULL);
+  HMAC_Update(ctx, data, len);
+  HMAC_Final(ctx, md, &hmac_len);
+  HMAC_CTX_free(ctx);
+
   dk_free_box ((box_t) data);
 
   len1 = xenc_encode_base64 ((char *)md, md64, hmac_len);
@@ -1753,7 +1762,6 @@
   return len;
 }
 
-#ifdef AES_ENC_ENABLE
 int xenc_aes_encryptor (dk_session_t * ses_in, long seslen, dk_session_t * ses_out,
 			   xenc_key_t * key, xenc_try_block_t * t)
 {
@@ -1763,7 +1771,7 @@
   caddr_t outbuf_beg;
   int len;
   caddr_t encoded_out;
-  EVP_CIPHER_CTX ctx;
+  EVP_CIPHER_CTX *ctx;
   unsigned char * ivec = &key->ki.aes.iv[0];
 
   CATCH_READ_FAIL (ses_in)
@@ -1778,7 +1786,7 @@
   END_READ_FAIL (ses_in);
 
 #if 1
-  EVP_CIPHER_CTX_init(&ctx);
+  ctx = EVP_CIPHER_CTX_new();
   outbuf_beg = dk_alloc_box (box_length (text) + 16, DV_BIN);
   memcpy (outbuf_beg, ivec, 16);
   outbuf = outbuf_beg + 16;
@@ -1786,33 +1794,32 @@
   switch (key->ki.aes.bits)
     {
     case 128:
-      EVP_EncryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL, key->ki.aes.k, ivec);
+      EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key->ki.aes.k, ivec);
       break;
     case 192:
-      EVP_EncryptInit_ex(&ctx, EVP_aes_192_cbc(), NULL, key->ki.aes.k, ivec);
+      EVP_EncryptInit_ex(ctx, EVP_aes_192_cbc(), NULL, key->ki.aes.k, ivec);
       break;
     case 256:
-      EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, key->ki.aes.k, ivec);
+      EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key->ki.aes.k, ivec);
       break;
     default:
       GPF_T1 ("Unsupported key size");
     }
-  if(!EVP_EncryptUpdate(&ctx, (unsigned char *)outbuf, &outlen, (unsigned char *)text, box_length (text)))
+  if(!EVP_EncryptUpdate(ctx, (unsigned char *)outbuf, &outlen, (unsigned char *)text, box_length (text)))
     {
-      EVP_CIPHER_CTX_cleanup(&ctx);
       dk_free_box (text);
       dk_free_box (outbuf_beg);
       xenc_report_error (t, 500, XENC_ENC_ERR, "AES encryption internal error #2");
     }
-  /* if(!EVP_EncryptFinal_ex(&ctx, outbuf + outlen, &tmplen))
+  /* if(!EVP_EncryptFinal_ex(ctx, outbuf + outlen, &tmplen))
     {
-      EVP_CIPHER_CTX_cleanup(&ctx);
+      EVP_CIPHER_CTX_free(ctx);
       dk_free_box (text);
       dk_free_box (outbuf_beg);
       xenc_report_error (t, 500, XENC_ENC_ERR, "AES encryption internal error #3");
       } */
   /* outlen += tmplen; */
-  EVP_CIPHER_CTX_cleanup(&ctx);
+  EVP_CIPHER_CTX_free(ctx);
 
 #else
   outbuf_beg = dk_alloc_box (box_length (text) + 16 /* iv */, DV_BIN);
@@ -1877,42 +1884,42 @@
   text += 16;
 
 #if 0
-  EVP_CIPHER_CTX_init(&ctx);
+  EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
   switch (key->ki.aes.bits)
     {
     case 128:
-      EVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL, key->ki.aes.k, ivec);
+      EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key->ki.aes.k, ivec);
       break;
     case 192:
-      EVP_DecryptInit_ex(&ctx, EVP_aes_192_cbc(), NULL, key->ki.aes.k, ivec);
+      EVP_DecryptInit_ex(ctx, EVP_aes_192_cbc(), NULL, key->ki.aes.k, ivec);
       break;
     case 256:
-      EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, key->ki.aes.k, ivec);
+      EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key->ki.aes.k, ivec);
       break;
     default:
       GPF_T1 ("unsupported key size");
     }
   outbuf = dk_alloc_box (len + EVP_MAX_BLOCK_LENGTH, DV_STRING);
 
-  if(!EVP_DecryptUpdate(&ctx, outbuf, &outlen, text, len - 16))
+  if(!EVP_DecryptUpdate(ctx, outbuf, &outlen, text, len - 16))
     {
-      EVP_CIPHER_CTX_cleanup(&ctx);
+      EVP_CIPHER_CTX_free(ctx);
       dk_free_box (text_beg);
       dk_free_box (outbuf);
       xenc_report_error (t, 500, XENC_ENC_ERR, "AES decryption internal error #2");
     }
-  if(!EVP_DecryptFinal_ex (&ctx, outbuf + outlen, &tmplen))
+  if(!EVP_DecryptFinal_ex (ctx, outbuf + outlen, &tmplen))
     {
       unsigned long err = ERR_get_error();
       char buf [120];
-      EVP_CIPHER_CTX_cleanup(&ctx);
+      EVP_CIPHER_CTX_free(ctx);
       dk_free_box (text_beg);
       dk_free_box (outbuf);
       xenc_report_error (t, 500, XENC_ENC_ERR, "AES decryption internal error %s",
 			 ERR_error_string (err, buf));
     }
   outlen += tmplen;
-  EVP_CIPHER_CTX_cleanup(&ctx);
+  EVP_CIPHER_CTX_free(ctx);
 #else
   AES_set_decrypt_key(key->ki.aes.k, key->ki.aes.bits, &aes_schedule);
   outlen = len - 16;
@@ -1932,7 +1939,8 @@
 #endif
   return 1;
 }
-#endif
+
+
 int
 xenc_dsa_encryptor (dk_session_t * ses_in, long seslen, dk_session_t * ses_out_base64,
 			xenc_key_t * key, xenc_try_block_t * t)
@@ -2050,6 +2058,7 @@
   int len = 0;
   int keysize;
   RSA * rsa = key->xek_private_rsa;
+  const BIGNUM *p, *q;
 
   if (!seslen)
     {
@@ -2062,9 +2071,9 @@
       xenc_report_error (t, 500 + strlen (key->xek_name), XENC_ENC_ERR, "could not make RSA decryption [key %s is not RSA]", key->xek_name);
       return 0;
     }
+  RSA_get0_factors(rsa, &p, &q);
   if (!rsa ||
-      !rsa->p ||
-      !rsa->q)
+      !p || !q)
     {
       if (key->xek_x509_KI)
 	key = xenc_get_key_by_keyidentifier (key->xek_x509_KI, 1);
@@ -2516,7 +2525,6 @@
 
 void xenc_aes_enctest_1 (const char * data)
 {
-#ifdef AES_ENC_ENABLE
   unsigned char key_data[16] = "0123456789ABCDEF";
   xenc_key_t * k = xenc_key_aes_create ("aes_k128", 128, (unsigned char *) key_data);
   dk_session_t *in, *out;
@@ -2549,7 +2557,6 @@
   strses_free (out);
   strses_free (in);
   xenc_key_remove (k, 1);
-#endif
 }
 
 void xenc_aes_enctest ()
diff -u -r -N virtuoso-opensource-o/libsrc/Wi/xmlenc.c virtuoso-opensource-7.2.5.1/libsrc/Wi/xmlenc.c
--- virtuoso-opensource-o/libsrc/Wi/xmlenc.c	2021-01-08 13:27:52.000000000 +0900
+++ virtuoso-opensource-7.2.5.1/libsrc/Wi/xmlenc.c	2021-01-08 13:37:01.000000000 +0900
@@ -66,6 +66,8 @@
 #include <openssl/err.h>
 #include <openssl/pem.h>
 
+#include "util/ssl_compat.h"
+
 #include "http.h"
 #include "libutil.h"
 #include "bif_text.h"
@@ -1192,12 +1194,10 @@
 	id_hash_remove (xenc_certificates, (caddr_t) & key->xek_x509_ref_str);
       dk_free_box (key->xek_x509_ref_str);
     }
-#ifdef AES_ENC_ENABLE
   if (key->xek_type == DSIG_KEY_AES)
     {
       dk_free (key->ki.aes.k, key->ki.aes.bits / 8 /* number of bits in byte */);
     }
-#endif
   if (key->xek_type == DSIG_KEY_RAW)
     {
       dk_free_box (key->ki.raw.k);
@@ -1385,15 +1385,7 @@
 
   if (type == CERT_TYPE_PEM_FORMAT) /* PEM format */
     {
-#if OPENSSL_VERSION_NUMBER >= 0x00908000L
-      x509 = (X509 *)PEM_ASN1_read_bio ((d2i_of_void *)d2i_X509,
-					PEM_STRING_X509,
-					b, NULL, NULL, NULL);
-#else
-      x509 = (X509 *)PEM_ASN1_read_bio ((char *(*)())d2i_X509,
-					PEM_STRING_X509,
-					b, NULL, NULL, NULL);
-#endif
+      x509 = (X509 *)PEM_ASN1_read_bio ((d2i_of_void *)d2i_X509, PEM_STRING_X509, b, NULL, NULL, NULL);
     }
   else if (type == CERT_TYPE_PKCS12_FORMAT) /* PKCS12 format */
     {
@@ -1426,14 +1418,7 @@
 
   if (b_priv)
     {
-#if OPENSSL_VERSION_NUMBER >= 0x00908000L
       private_key = PEM_read_bio_PrivateKey(b_priv, NULL, pass_cb, (void *) private_key_passwd);
-#else
-      private_key = (EVP_PKEY*)PEM_ASN1_read_bio ((char *(*)())d2i_PrivateKey,
-					     PEM_STRING_EVP_PKEY,
-					     b_priv,
-					     NULL, pass_cb, (void *) private_key_passwd);
-#endif
       if (!private_key)
 	{
 #if 0
@@ -1455,19 +1440,19 @@
 
   if (pkey)
     {
-      switch (EVP_PKEY_type (pkey->type))
+      switch (EVP_PKEY_type (EVP_PKEY_id(pkey)))
 	{
 	case EVP_PKEY_DSA:
 	  sign_algoname = DSIG_DSA_SHA1_ALGO;
 	  enc_algoname = XENC_DSA_ALGO;
-	  dsa = pkey->pkey.dsa;
-	  private_dsa = private_key ? private_key->pkey.dsa : 0;
+	  dsa = EVP_PKEY_get0_DSA(pkey);
+	  private_dsa = private_key ? EVP_PKEY_get0_DSA(private_key) : 0;
 	  break;
 	case EVP_PKEY_RSA:
 	  sign_algoname = DSIG_RSA_SHA1_ALGO;
 	  enc_algoname = XENC_RSA_ALGO;
-	  rsa = pkey->pkey.rsa;
-	  private_rsa = private_key ? private_key->pkey.rsa : 0;
+	  rsa = EVP_PKEY_get0_RSA(pkey);
+	  private_rsa = private_key ? EVP_PKEY_get0_RSA(private_key) : 0;
 	  break;
 	default:
 	  goto finish;
@@ -1588,15 +1573,23 @@
       dh = DH_new ();
       bn_p = BN_bin2bn ((unsigned char *)mod, p_len, NULL);
       bn_g = BN_bin2bn (g_bin, 1, NULL);
-      dh->p = bn_p;
-      dh->g = bn_g;
+      if (dh)
+        DH_set0_pqg(dh, bn_p, NULL, bn_g);
 
       dk_free_box (mod_b64);
       dk_free_box (mod);
     }
   else
     {
-      dh = DH_generate_parameters (num, g, dh_cb, NULL);
+      dh = DH_new ();
+      if (dh)
+	{
+	  if (!DH_generate_parameters_ex (dh, num, g, NULL))
+	    {
+	      DH_free (dh);
+	      dh = NULL;
+	    }
+	}
     }
   if (!dh)
     {
@@ -1641,19 +1634,19 @@
   switch (param)
     {
   	case 1:
-	 num = dh->p;
+	 DH_get0_pqg(dh, &num, NULL, NULL);
 	 break;
 	case 2:
-	 num = dh->g;
+	 DH_get0_pqg(dh, NULL, NULL, &num);
 	 break;
 	case 3:
-	 num = dh->pub_key;
+	 DH_get0_key(dh, &num, NULL);
 	 break;
 	case 4:
-	 num = dh->priv_key;
+	 DH_get0_key(dh, NULL, &num);
 	 break;
 	default:
-	 num = dh->pub_key;
+	 DH_get0_key(dh, &num, NULL);
     }
 
   buf_len = (size_t)BN_num_bytes(num);
@@ -1884,7 +1877,6 @@
 	      memcpy (key->ki.triple_des.k3, &_key[2], sizeof (DES_cblock));
 	      break;
 	    }
-#ifdef AES_ENC_ENABLE
       case DSIG_KEY_AES:
 	    {
 	      key->ki.aes.k = (unsigned char *) dk_alloc (key_len / 8);
@@ -1892,7 +1884,6 @@
 	      memcpy (key->ki.aes.k, &_key[0], key_len / 8);
 	      break;
 	    }
-#endif
       default:
 	  return NULL;
     }
@@ -2280,12 +2271,12 @@
     {
       in = BIO_new_mem_buf (key_base64, len);
       pkey = d2i_PUBKEY_bio (in, NULL);
-      if (pkey && pkey->type == EVP_PKEY_RSA)
-	p = pkey->pkey.rsa;
+      if (pkey && EVP_PKEY_id(pkey) == EVP_PKEY_RSA)
+	p = EVP_PKEY_get0_RSA(pkey);
       BIO_reset (in);
       pkkey = d2i_PrivateKey_bio (in, NULL);
-      if (pkkey && pkkey->type == EVP_PKEY_RSA)
-	r = pkkey->pkey.rsa;
+      if (pkkey && EVP_PKEY_id(pkkey) == EVP_PKEY_RSA)
+	r = EVP_PKEY_get0_RSA(pkkey);
       BIO_free (in);
     }
   else
@@ -2304,9 +2295,11 @@
 
   if (!p)
     {
+      const BIGNUM *n, *e;
+
+      RSA_get0_key(r, &n, &e, NULL);
       p = RSA_new ();
-      p->n = BN_dup (r->n);
-      p->e = BN_dup (r->e);
+      RSA_set0_key(p, BN_dup(n), BN_dup(e), NULL);
     }
 
   mutex_enter (xenc_keys_mtx);
@@ -2355,14 +2348,13 @@
   p = RSA_new ();
   n = BN_bin2bn ((unsigned char *) mod, box_length (mod) - 1, NULL);
   e = BN_bin2bn ((unsigned char *) exp, box_length (exp) - 1, NULL);
-  p->n = n;
-  p->e = e;
+  RSA_set0_key(p, n, e, NULL);
   if (pexp)
     {
       pk = RSA_new ();
-      pk->d = BN_bin2bn ((unsigned char *) pexp, box_length (pexp) - 1, NULL);
-      pk->n = BN_dup (n);
-      pk->e = BN_dup (e);
+      RSA_set0_key(p, BN_dup(n),
+		      BN_dup(e),
+		      BN_bin2bn ((unsigned char *) pexp, box_length (pexp) - 1, NULL));
     }
   mutex_enter (xenc_keys_mtx);
   k = xenc_key_create (name, XENC_RSA_ALGO, DSIG_RSA_SHA1_ALGO, 0);
@@ -2725,7 +2717,6 @@
   return ret;
 }
 
-#ifdef AES_ENC_ENABLE
 xenc_key_t * xenc_key_aes_create (const char * name, int keylen, const char * pwd)
 {
   char _key[KEYSIZB+1];
@@ -2801,7 +2792,6 @@
 
   return box_dv_short_string (k->xek_name);
 }
-#endif
 
 #ifdef _KERBEROS
 
@@ -4111,12 +4101,15 @@
   caddr_t ** array;
   if (key->xek_type == DSIG_KEY_RSA)
     {
+      const BIGNUM *rsa_n, *rsa_e;
+
+      RSA_get0_key(key->ki.rsa.rsa_st, &rsa_n, &rsa_e, NULL);
       xenc_tag_t * rsakeyval = xenc_tag_create (DSIG_URI, ":RSAKeyValue");
       xenc_tag_t * rsamodulus = xenc_tag_create (DSIG_URI, ":Modulus");
       xenc_tag_t * rsaexponent = xenc_tag_create (DSIG_URI, ":Exponent");
 
-      xenc_tag_add_child_BN (rsamodulus, key->ki.rsa.rsa_st->n);
-      xenc_tag_add_child_BN (rsaexponent, key->ki.rsa.rsa_st->e);
+      xenc_tag_add_child_BN (rsamodulus, rsa_n);
+      xenc_tag_add_child_BN (rsaexponent, rsa_e);
 
       xenc_tag_add_child (rsakeyval, xenc_tag_finalize (rsamodulus));
       xenc_tag_add_child (rsakeyval, xenc_tag_finalize (rsaexponent));
@@ -4135,12 +4128,15 @@
       xenc_tag_t * g = xenc_tag_create (DSIG_URI, ":G");
       xenc_tag_t * y = xenc_tag_create (DSIG_URI, ":Y");
       DSA * dsa = key->ki.dsa.dsa_st;
+      const BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;
 
+      DSA_get0_pqg(dsa, &dsa_p, &dsa_q, &dsa_g);
+      DSA_get0_key(dsa, &dsa_pub_key, NULL);
 
-      xenc_tag_add_child_BN (p, dsa->p);
-      xenc_tag_add_child_BN (p, dsa->q);
-      xenc_tag_add_child_BN (p, dsa->g);
-      xenc_tag_add_child_BN (p, dsa->pub_key);
+      xenc_tag_add_child_BN (p, dsa_p);
+      xenc_tag_add_child_BN (p, dsa_q);
+      xenc_tag_add_child_BN (p, dsa_g);
+      xenc_tag_add_child_BN (p, dsa_pub_key);
 
       xenc_tag_add_child (dsakeyval, xenc_tag_finalize (p));
       xenc_tag_add_child (dsakeyval, xenc_tag_finalize (q));
@@ -4306,7 +4302,6 @@
 	}
       END_WRITE_FAIL (ses);
       break;
-#ifdef AES_ENC_ENABLE
     case DSIG_KEY_AES:
       CATCH_WRITE_FAIL (ses)
 	{
@@ -4317,7 +4312,6 @@
 	}
       END_WRITE_FAIL (ses);
       break;
-#endif
     case DSIG_KEY_RAW:
       /* */
       CATCH_WRITE_FAIL (ses)
@@ -6187,7 +6181,7 @@
 
   ret = dk_alloc_box (ikeyid->length, DV_BIN);
   memcpy (ret, ikeyid->data, ikeyid->length);
-  M_ASN1_OCTET_STRING_free(ikeyid);
+  ASN1_OCTET_STRING_free(ikeyid);
   return ret;
 }
 
@@ -6247,7 +6241,7 @@
 
   ret = dk_alloc_box (ikeyid->length, DV_BIN);
   memcpy (ret, ikeyid->data, ikeyid->length);
-  M_ASN1_OCTET_STRING_free(ikeyid);
+  ASN1_OCTET_STRING_free(ikeyid);
   return ret;
 }
 
@@ -6806,7 +6800,7 @@
 	sk_X509_EXTENSION_push(st_exts, ex);
     }
   X509_REQ_add_extensions(x, st_exts);
-  if (!X509_REQ_sign (x, pk, (pk->type == EVP_PKEY_RSA ? EVP_md5() : EVP_dss1())))
+  if (!X509_REQ_sign (x, pk, (EVP_PKEY_id(pk) == EVP_PKEY_RSA ? EVP_md5() : EVP_sha1())))
     {
       pk = NULL; /* keep one in the xenc_key */
       *err_ret = srv_make_new_error ("42000", "XECXX", "Can not sign certificate : %s", get_ssl_error_text (buf, sizeof (buf)));
@@ -6945,17 +6939,17 @@
       *err_ret = srv_make_new_error ("42000", "XECXX", "Can not sign certificate");
       goto err;
     }
-  switch (EVP_PKEY_type (cli_pk->type))
+  switch (EVP_PKEY_type (EVP_PKEY_id(cli_pk)))
     {
       case EVP_PKEY_DSA:
 	  sign_algoname = DSIG_DSA_SHA1_ALGO;
 	  enc_algoname = XENC_DSA_ALGO;
-	  dsa = cli_pk->pkey.dsa;
+	  dsa = EVP_PKEY_get0_DSA(cli_pk);
 	  break;
       case EVP_PKEY_RSA:
 	  sign_algoname = DSIG_RSA_SHA1_ALGO;
 	  enc_algoname = XENC_RSA_ALGO;
-	  rsa = cli_pk->pkey.rsa;
+	  rsa = EVP_PKEY_get0_RSA(cli_pk);
 	  break;
       default:
 	  *err_ret = srv_make_new_error ("42000", "XECXX", "The type of public key is not supported mus tbe RSA or DSA");
@@ -7013,7 +7007,8 @@
   char *data_ptr;
   int len;
   caddr_t ret = NULL;
-  STACK_OF (X509) * chain = NULL, *certs = NULL;
+  STACK_OF (X509) * chain = NULL;
+  STACK_OF (X509) * certs = NULL;
   STACK_OF (X509_INFO) * inf = NULL;
 
   if (!key || !key->xek_evp_private_key || !key->xek_x509)
@@ -7032,19 +7027,25 @@
   if (export_chain)
     {
       int i;
-      X509_STORE_CTX store_ctx;
-      X509_STORE_CTX_init (&store_ctx, CA_certs, x, NULL);
-      if (X509_verify_cert (&store_ctx) > 0)
-	chain = X509_STORE_CTX_get1_chain (&store_ctx);
+      X509_STORE_CTX *store_ctx = NULL;
+      store_ctx = X509_STORE_CTX_new();
+      X509_STORE_CTX_init (store_ctx, CA_certs, x, NULL);
+      if (!store_ctx)
+	goto err;
+      
+      if (X509_verify_cert (store_ctx) > 0)
+	chain = X509_STORE_CTX_get1_chain (store_ctx);
       else
 	{
 	  const char *err_str;
-	  err_str = X509_verify_cert_error_string (store_ctx.error);
+	  err_str = X509_verify_cert_error_string (X509_STORE_CTX_get_error(store_ctx));
 	  *err_ret = srv_make_new_error ("22023", "XENCX", "X509 error: %s", err_str);
-	  X509_STORE_CTX_cleanup (&store_ctx);
+	  X509_STORE_CTX_cleanup (store_ctx);
+	  X509_STORE_CTX_free (store_ctx);
 	  goto err;
 	}
-      X509_STORE_CTX_cleanup (&store_ctx);
+      X509_STORE_CTX_cleanup (store_ctx);
+      X509_STORE_CTX_free (store_ctx);
       if (chain)
 	{
 	  certs = sk_X509_new_null ();
@@ -7152,16 +7153,16 @@
     {
       k = X509_get_pubkey (key->xek_x509);
 #ifdef EVP_PKEY_RSA
-      if (k->type == EVP_PKEY_RSA)
+      if (EVP_PKEY_id(k) == EVP_PKEY_RSA)
 	{
-	  RSA * x = k->pkey.rsa;
+	  RSA *x = EVP_PKEY_get0_RSA(k);
 	  PEM_write_bio_RSA_PUBKEY (b, x);
 	}
 #endif
 #ifdef EVP_PKEY_DSA
-      if (k->type == EVP_PKEY_DSA)
+      if (EVP_PKEY_id(k) == EVP_PKEY_DSA)
 	{
-	  DSA * x = k->pkey.dsa;
+	  DSA * x = EVP_PKEY_get0_DSA(k);
 	  PEM_write_bio_DSA_PUBKEY (b, x);
 	}
 #endif
@@ -7208,16 +7209,16 @@
     {
       k = X509_get_pubkey (key->xek_x509);
 #ifdef EVP_PKEY_RSA
-      if (k->type == EVP_PKEY_RSA)
+      if (EVP_PKEY_id(k) == EVP_PKEY_RSA)
 	{
-	  RSA * x = k->pkey.rsa;
+	  RSA * x = EVP_PKEY_get0_RSA(k);
 	  i2d_RSA_PUBKEY_bio (b, x);
 	}
 #endif
 #ifdef EVP_PKEY_DSA
-      if (k->type == EVP_PKEY_DSA)
+      if (EVP_PKEY_id(k) == EVP_PKEY_DSA)
 	{
-	  DSA * x = k->pkey.dsa;
+	  DSA * x = EVP_PKEY_get0_DSA(k);
 	  i2d_DSA_PUBKEY_bio (b, x);
 	}
 #endif
@@ -7280,8 +7281,14 @@
 xenc_rsa_pub_magic (RSA * x)
 {
   caddr_t ret;
-  caddr_t n = BN2binbox (x->n); /* modulus */
-  caddr_t e = BN2binbox (x->e); /* public exponent */
+  caddr_t n;
+  caddr_t e;
+  const BIGNUM *rsa_n, *rsa_e;
+
+  RSA_get0_key(x, &rsa_n, &rsa_e, NULL);
+  n = BN2binbox (rsa_n); /* modulus */
+  e = BN2binbox (rsa_e); /* public exponent */
+
   n = xenc_encode_base64_binbox (n, 1);
   e = xenc_encode_base64_binbox (e, 1);
   ret = dk_alloc_box (box_length (n) + box_length (e) + 4 /* two dots - one trailing zero + RSA prefix */, DV_STRING);
@@ -7306,9 +7313,9 @@
     {
       k = X509_get_pubkey (key->xek_x509);
 #ifdef EVP_PKEY_RSA
-      if (k->type == EVP_PKEY_RSA)
+      if (EVP_PKEY_id(k) == EVP_PKEY_RSA)
 	{
-	  RSA * x = k->pkey.rsa;
+	  RSA * x = EVP_PKEY_get0_RSA(k);
 	  ret = xenc_rsa_pub_magic (x);
 	}
 #endif
@@ -7349,10 +7356,16 @@
 xenc_rsa_pub_ssh_export (RSA * x)
 {
   static char * ssh_header = "\x00\x00\x00\x07ssh-rsa";
+  const BIGNUM *rsa_n, *rsa_e;
   caddr_t ret;
   int len, pos;
-  caddr_t n = BN2binbox (x->n); /* modulus */
-  caddr_t e = BN2binbox (x->e); /* public exponent */
+  caddr_t n;
+  caddr_t e;
+
+  RSA_get0_key(x, &rsa_n, &rsa_e, NULL);
+  n = BN2binbox (rsa_n); /* modulus */
+  e = BN2binbox (rsa_e); /* public exponent */
+
   len = 11 + 8 + box_length (n) + box_length (e);
   if (n[0] & 0x80)
     len ++;
@@ -7383,9 +7396,9 @@
     {
       k = X509_get_pubkey (key->xek_x509);
 #ifdef EVP_PKEY_RSA
-      if (k->type == EVP_PKEY_RSA)
+      if (EVP_PKEY_id(k) == EVP_PKEY_RSA)
 	{
-	  RSA * x = k->pkey.rsa;
+	  RSA * x = EVP_PKEY_get0_RSA(k);
 	  ret = xenc_rsa_pub_ssh_export (x);
 	}
 #endif
@@ -7418,7 +7431,7 @@
       return NULL;
     }
   pk = NETSCAPE_SPKI_get_pubkey (spki);
-  if (!pk || pk->type != EVP_PKEY_RSA)
+  if (!pk || EVP_PKEY_id(pk) != EVP_PKEY_RSA)
     {
       NETSCAPE_SPKI_free (spki);
       *err_ret = srv_make_new_error ("42000", "XECXX", "Can not retrieve RSA key");
@@ -7595,14 +7608,14 @@
   sec_check_dba ((QI*)qst, me);
   in = BIO_new (BIO_s_mem ());
   mutex_enter (xenc_keys_mtx);
-  certs = CA_certs->objs;
+  certs = X509_STORE_get0_objects(CA_certs);
   len = sk_X509_OBJECT_num (certs);
   for (i = 0; i < len; i++)
     {
       X509_OBJECT * obj = sk_X509_OBJECT_value (certs, i);
-      if (obj->type == X509_LU_X509)
+      if (X509_OBJECT_get_type(obj) == X509_LU_X509)
 	{
-	  X509 *x = obj->data.x509;
+	  X509 *x = X509_OBJECT_get0_X509(obj);
 	  caddr_t itm;
 	  int blen;
 	  BIO_reset (in);
@@ -7666,7 +7679,6 @@
 			  xenc_dsa_decryptor,
 			  DSIG_KEY_DSA);
 
-#ifdef AES_ENC_ENABLE
   xenc_algorithms_create (XENC_AES128_ALGO, "aes 128 cbc encoding algorithm",
 			  xenc_aes_encryptor,
 			  xenc_aes_decryptor,
@@ -7679,7 +7691,6 @@
 			  xenc_aes_encryptor,
 			  xenc_aes_decryptor,
 			  DSIG_KEY_AES);
-#endif
 
   xenc_algorithms_create (XENC_DH_ALGO, "dh encoding algorithm",
 			  xenc_dh_encryptor,
@@ -7712,10 +7723,8 @@
 
   bif_define ("dsig_template_ext", bif_dsig_template_ext);
 
-#ifdef AES_ENC_ENABLE
   bif_define ("xenc_key_AES_create", bif_xenc_key_aes_create);
   bif_define ("xenc_key_AES_rand_create", bif_xenc_key_aes_rand_create);
-#endif
 
   bif_define ("xenc_key_3DES_read", bif_xenc_key_3des_read);
   bif_define ("xenc_key_RSA_read", bif_xenc_key_rsa_read);
diff -u -r -N virtuoso-opensource-o/libsrc/Wi/xmlenc-dec.c virtuoso-opensource-7.2.5.1/libsrc/Wi/xmlenc-dec.c
--- virtuoso-opensource-o/libsrc/Wi/xmlenc-dec.c	2021-01-08 13:27:52.000000000 +0900
+++ virtuoso-opensource-7.2.5.1/libsrc/Wi/xmlenc-dec.c	2021-01-08 13:37:01.000000000 +0900
@@ -1920,7 +1920,6 @@
 	}
       xenc_key_3des_init (key, key_raw_data, key_raw_data + 8, key_raw_data + 16);
       break;
-#ifdef AES_ENC_ENABLE
     case DSIG_KEY_AES:
       /* len = decode_base64 (key_raw_data, key_raw_data + box_length (key_raw_data) - 1); */
       len = strses_length (in);
@@ -1944,7 +1943,6 @@
       memset (key->ki.aes.iv, 0, sizeof (key->ki.aes.iv));
       memcpy (key->ki.aes.k, key_raw_data, key->ki.aes.bits / 8 /* bits in one byte */);
       break;
-#endif
     default:;
       /* do nothing */
     }
diff -u -r -N virtuoso-opensource-o/libsrc/Wi/xmlenc.h virtuoso-opensource-7.2.5.1/libsrc/Wi/xmlenc.h
--- virtuoso-opensource-o/libsrc/Wi/xmlenc.h	2021-01-08 13:27:52.000000000 +0900
+++ virtuoso-opensource-7.2.5.1/libsrc/Wi/xmlenc.h	2021-01-08 13:37:01.000000000 +0900
@@ -26,11 +26,6 @@
 #ifndef XMLENC_ALGO_H
 #define XMLENC_ALGO_H
 #include <openssl/opensslv.h>
-#if (OPENSSL_VERSION_NUMBER < 0x00907000L)
-/*#warning aes is not supported*/
-#else
-#define AES_ENC_ENABLE
-#endif
 
 #define OPENSSL_DISABLE_OLD_DES_SUPPORT
 
@@ -39,9 +34,7 @@
 #include <openssl/rsa.h>
 #include <openssl/des.h>
 
-#ifdef AES_ENC_ENABLE
 #include <openssl/aes.h>
-#endif
 
 #include <openssl/x509.h>
 #include <openssl/rand.h>
@@ -326,7 +319,6 @@
 #define PKCS5_SALT_LEN			8
       unsigned char salt[PKCS5_SALT_LEN];
     } triple_des;
-#ifdef AES_ENC_ENABLE
     struct dsig_aes_keyinfo_s
     {
       /* key */
@@ -334,7 +326,6 @@
       int		bits;
       unsigned char	iv[16];
     } aes;
-#endif
 #ifdef _KERBEROS
     struct dsig_kerberos_s
     {
